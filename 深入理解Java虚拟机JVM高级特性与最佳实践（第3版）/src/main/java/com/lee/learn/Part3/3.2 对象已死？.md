在堆中存放着Java中几乎所有对象的实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象中哪些还存活着，哪些已经死去

引用计数算法
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器减一；任何时刻计数器为零的对象就是不可能在被使用的

可达性分析算法
通过称为GC Roots的根对象作为起始节点集，从这个节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连或从GC Roots到这个对象不可达，则此对象不能在被使用
Java技术体系中，固定可作为GC Roots的对象包括：
1.在虚拟机栈中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2.在方法区中类静态属性引用的对象，如Java类的引用类型静态变量
3.在方法区中常量引用的对象，如字符串常量池中的引用
4.在本地方法栈中的JNI引用的对象
5.Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象NullPointException等，还有系统类加载器
6.所有被同步锁持有的对象
7.反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

JDK1.2前，一个对象只有“被引用”或“未被引用”两种状态。
JDK1.2后，对引用概念进行了扩充，分为强引用、软引用、弱引用和虚引用
强引用
是最传统的引用的定义，指代码中普遍存在的引用赋值，即类是Object obj = new Object()这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用对象
软引用
是用来描述一些还有用的，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前，会将这些对象列进回收范围中进行第二次回收，如果这次回收没有足够的内存，才会抛出内存溢出异常。使用SoftReference类实现软引用
弱引用
用来描述那些非必须对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集器发生为止，当垃圾收集开始工作，无论当前内存是否足够，都会回收到只被弱引用关联的对象。使用WeakReference类实现弱引用
虚引用
也称幽灵引用或幻影引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设计虚引用关联的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知。使用PhantomReference类实现虚引用



方法区的回收
主要回收两部分：废弃的常量和不再使用的类型

判定一个常量是否废弃：假如一个字符串java曾进入常量池，但当前系统中又没有任何一个字符串对象的值是java，那么这个常量就会会清理

判断一个类型是否属于不再使用：要同时满足三个条件
1.该类所有实例都已被回收，就是说Java堆中不存在该类及其任何派生子类的实例
2.加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换加载器的场景如OSGi、JSP的重加载等，否则通常是很难达成的
3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法