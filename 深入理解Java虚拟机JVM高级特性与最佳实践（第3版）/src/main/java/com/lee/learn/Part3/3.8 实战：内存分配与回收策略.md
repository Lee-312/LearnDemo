##### 1.对象优先在Eden分配

大多数情况，对象在新生代Eden区中分配，当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC

##### 2.大对象直接进入老年代

大对象就是指需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串或者元素数量很庞大的数组。大对象对于虚拟机的内存分配来说是个不折不扣的坏消息，比遇到一个大对象更坏的消息就是遇到一群朝生夕灭的短命大对象，写程序应避免这个情况。要避免大对象的原因时，在分配空间时，它容易导致明明有不少内存空间就提前触发垃圾收集，以获取足够的连续空间，而当复制对象时，大对象就意味着高额的内存复制开销

##### 3.长期存活的对象将进入老年代

通常对象在Eden区诞生，如果经过第一次Minor GC后仍存活，并能被Survivor容纳，那对象就会被移至Survivor，并将对象设为1岁，在Survivor中每熬过一次Minor GC年龄就加一，当到达一定年龄后就会被晋升到老年代中，默认15岁

##### 4.动态对象年龄判定

为了更好的适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄达到设定值才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

##### 5.空间分配担保

在发生Minor GC前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件承类，那这次Minor GC可用确保是安全的，否则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败，如果允许那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试一次Minor GC，尽管这次Minor GC是有风险的，如果小于或设置不允许冒险，那就要改为一次Full GC