复用代码是Java众多引人注目的功能之一。但想要成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情

组合：只需在新的类中产生现有类的对象  
继承：按照现有类的类型来创建新类，无需改变现有类的形式，采用现有类的形式并在其中添加代码

#### 7.1 组合语法

编译器并不是简单的为每个引用都创建默认对象，如果想初始化引用，可以在下列位置:  
a.在定义对象的地方  
b.在类的构造器中  
c.就在正要使用对象之前（惰性初始化）  
d.使用实例初始化

#### 7.2 继承语法

当创建一个类时，总是在继承，因此除非已明确指出要从其他类中继承，否则就是在隐式的从Java的标准根类Object进行继承   
继承过程中，需要声明新类与旧类相似，使用extends关键字实现，当这么做时，会自动得到基类中所有的域和方法  
希望在新类中能够调用超类的方法，使用super方法

##### 7.2.1 初始化基类

会自动在导出类的构造器中插入对基类构造器的调用  
构建过程是从基类向外扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化  
如果想调用基类带参数的构造器，就必须借助super关键字显示的编写调用语句

#### 7.3 代理

java没有提供对它的直接支持，这是继承和组合之间的中庸之道

#### 7.4 结合使用组合和继承

##### 7.4.1 确保正确清理

清理方法（dispose()）中，需注意对基类清理方法和成员对象清理方法的调用顺序，以防某个子对象依赖另一个子对象情形的发生  
执行类的所有特定的清理动作，其顺序同生成顺序相反，然后，调用基类的清理方法

##### 7.4.2 名称屏蔽

@Override注解可以防止在不想重载时而意外进行了重载

#### 7.5 在组合域继承之间选择

组合和继承都允许在新类中放置子类对象，组合是显式的这样做，而继承是隐式的做

#### 7.6 protected关键字

protexted就对于类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一包内的类来说，它是可访问的

#### 7.7 向上转型

“为新的类提供方法”并不是继承技术中最重要的方面。其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”加以概括

##### 7.7.1 为什么称为向上转型

由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型，由于向上转型是从一个较专用类型向较通用类型转换，所以总是安全的。也就是说导出类是基类的一个超集，它可能比基类含有更多的方法，但它必须至少具备基类中所包含的方法。在向上转型的过程中，类接口中唯一可能发生的事情的丢失方法，而不是获取它们

##### 7.7.2 再论组合与继承

到底使用组合还是继承，一个最清晰的判断办法就是问一问是否需要从新类向基类进行向上转型。如果向上转型是必须的，则继承是必要的；如果不需要，则应当好好考虑是否需要继承

#### 7.8 final关键字

通常指，这是无法改变的。不想做改变可能出于两种理由：设计或效率  
final可能会用到的三种情况：数据、方法和类

##### 7.8.1 final数据

final修饰数据时表示这是一块恒定不变的数据  
一个既是static又是final的域只占据一段不能改变的存储内存  
对于基本数据类型，final时值恒定不变；对于引用数据类型，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，但是，对象其自身却是可以被修改的。Java未提供使任何对象恒定不变的途径，这一限制同样适用于数组，它也是对象。  
java允许使用空白null（声明为final但又未给定初始值的域），无论什么情况，编译器都确保空白final在使用前必须被初始化  
java允许在参数列表中以声明方式将参数指明为final，这意外着无法在方法中更改参数引用所指向的对象

##### 7.8.2 final方法

使用final方法的原因有两个，  
1：把方法锁住，防止任何继承类修改它的含义  
2：效率，过去由于内嵌调用的关系，目前已不再需要使用final进行优化了  

类中所有的private方法都隐式的指定为final的  
如果某方法使private。它就不是基类的接口的一部分，它仅是一些隐藏于类中的程序代码，只不过具有相同名称而已。但如果导出类中已相同名称生成一个public、protected或包访问权限的方法，该方法就不会产生在基类中出现的”仅具有相同名称“的情况。此时并没有覆盖该方法，仅是生成了一个新方法。由于private方法无法触及而且能有效隐藏，所以除了把它看成是因为它所归属的类的组织结构的原因而存在外，其他任何事物都不需要考虑到它

##### 7.8.3 final类

当某个类定义为final时，表明你不打算继承该类，而且也不允许别人这样做  
final类禁止继承，其类中所有的方法都隐式的指定为final

##### 7.8.4 有关final的忠告

#### 7.9 初始化及类的加载

##### 7.9.1 继承与初始化

见Beetle.java类