可以将一个类的定义放在另一个类的定义内部，这就是内部类

#### 10.1 创建内部类

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像Parcel2.java中那样，具体的指明这个对象的类型：OuterClassName.InnerClassName

#### 10.2 链接到外部类

当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员吗，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权

#### 10.3 使用.this与.new

创建某某个内部类的对象，必须在new表达式中提供对其他外部类对象的引用，这是需要使用.new语法的  
要想直接创建内部类，必须使用外部类的对象来进行创建  
在拥有外部类对象之前是不可能创建内部类对象，这是因为内部类对象会暗暗地连接到创建它的外部类对象上，但是，如果是嵌套类（静态内部类）那么就不需要对外部类对象的引用

#### 10.4 内部类与向上转型

#### 10.5 在方法和作用域内的内部类

1.一个定义在方法中的类 Parcel5.java  
2.一个定义在作用域内的类，此作用域在方法的内部 Parcel6.java  
3.一个实现了接口的匿名类 Parcel7.java  
4.一个匿名类，它扩展了有非默认构造器的类 Parcel8.java  
5.一个匿名类，它执行字段初始化 Parcel9.java  
6.一个匿名类，它通过实例初始化实现构造  Parcel10.java 

局部内部类：在方法的作用域内创建一个完整的类

#### 10.6 匿名内部类

如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。  
如果希望做一些类时构造器的行为，在匿名内部类中是不可能有命名构造器，但通过实例初始化，就能达到为其创建一个构造器的效果  
匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口。但是不能两者兼具，而且如果是实现接口，也只能实现一个接口

##### 10.6.1 再访工厂方法

#### 10.7 嵌套类

如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static，这通常称为嵌套类  
普通的内部类对象隐式的保存了一个引用，指向创建它的外围类对象  
但是当内部类是static时，意味着  
1.要创建嵌套类的对象，并不需要其外围类对象  
2.不能从嵌套类的对象中访问非静态的外围类对象

普通内部类与嵌套类的区别，普通内部类的字段与方法，只能放在了类的外部层次上，所以普通内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含这些东西

##### 10.7.1 接口内部的类

嵌套类可以作为接口的一部分，接口上的任何类都是public和static的，因为类是static的，只是将嵌套类置于接口的命名空间内，并不违法接口的规则，甚至可以在内部类中实现其外围接口

##### 10.7.2 从多层嵌套类中访问外部类的成员

一个内部类被嵌套多少层不重要，它能透明的访问所有它所嵌入的外围类的所有成员

#### 10.8 为什么需要内部类

内部类实现一个接口与外围类实现这个接口有什么区别呢？  
后着不能总是享用到接口带来的方便，有时需要用到接口的实现，所以使用内部类最吸引人的是：每个内部类都能独立地继承自一个接口的实现，所有无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响

内部类使得多重继承的解决方案变得完整，接口解决了部分问题，而内部类有效的实现了“多重继承”

内部类还可以获得一些其他特性：  
1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立  
2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个接口  
3.创建内部类对象的时刻并不依赖于外围类对象的创建  
4.内部类并没有令人迷惑的“is-a"关系，它就是一个独立的实体

##### 10.8.1 闭包与回调

闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域

##### 10.8.2 内部类与控制框架

#### 10.9 内部类的继承

因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂，问题在于那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊语法来明确说清它们间的关系，见InheritInner.java的wi.super();语法，这样才能通过编译

#### 10.10 内部类可以被覆盖吗

#### 10.11 局部内部类

局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，以及此外围类的所有成员

使用局部内部类而不使用匿名内部类的理由是：  
1.需要一个已命名的构造器或者需要重载构造器，而匿名内部类只能用于实例初始化；  
2.需要不止一个给内部类的对象

#### 10.12 内部类标识符

内部会会生成的class对象名称：外围类的名字 + $ + 内部类的名字

如果内部类的匿名的，编译器会简单的产生一个数字作为其标识符。如果内部类是嵌套在别的内部类中，只需要将它的名字加在其外围类标识符与$后面