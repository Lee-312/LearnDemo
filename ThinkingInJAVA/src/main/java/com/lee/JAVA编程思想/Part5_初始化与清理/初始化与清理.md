#### 5.1 用构造器确保初始化

假想编写的每个类都有一个init()方法，该方法提醒在使用该类前首先调用init()，这意味着用户必须记得自己去调用此方法。在java中通过提供构造器，类的设计者可以确保每个对象都会得到初始化。创建对象时，如果其类有构造器，Java就会在用户有能力操作对象前自动调用相应的构造器，从而保证了初始化的进行。  
java中构造器采用与类名的形式。  
不接受任何参数的构造器叫无参构造器或默认构造器  
java中初始化和创建捆绑在一起，两者不能分离  
构造器是一种特殊类型的方法，它没有返回值

#### 5.2 方法重载

为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载

##### 5.2.1 区分重载方法

参数顺序的不同也足以区分两个方法

##### 5.2.2 涉及基本类型的重载

PrimitiveOverloading.java  
如果传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会被提升。char略有不同，如果无法找到恰好接受char的方法，就会把char直接提升至int  
如果传入的数据类型大于方法中声明的，就必须通过类型转换来执行窄化转换，如果不这样做，编译器就会报错

##### 5.2.3 以返回值区分重载方法

#### 5.3 默认构造器

如果编写的类中没有构造器，则编译器会自动创建一个默认构造器；但是如果已经定义了一个构造器（无论是否有参），编译器就不会自动创建构造器

#### 5.4 this关键字

this关键字只能在方法内部使用，表示对“调用方法的那个对象” 

##### 5.4.1 在构造器中调用构造器

运用this关键字  
尽管可以使用this调用构造器，但却不能在一个构造器中同时调用另外两个构造器；  
必须将构造器调用置于最起始处，否则编译器会报错；  
除构造器外，编译器禁止在其他任何方法中调用构造器

#### 5.4.2 static的含义

static就是没有this的方法，在static方法的内部不能调用非静态方法，反之倒是可以的

#### 5.5 清理：终结处理和垃圾回收

垃圾回收器负责回收无用对象占用的内存资源  
但有特殊情况，假定对象（并非使用new）获得一块“特殊”的内存区域，由于垃圾回收器只知道释放经由new分配的对象，所以它不知如何释放该对象的这块内存，为应对此情况，java允许在类中定义名为finalize()的方法。

JAVA里的对象并非总是被垃圾回收

##### 5.5.1 finalize()的用途何在

由于分配内存时采用了类似C语言的做法，调用了本地方法，C会调用malloc()函数系列分配存储空间，free()释放空间，如果存储空间得不到释放，会造成内存泄漏。此时需要在在finalize()中用本地方法进行调用处理

##### 5.5.2 你必须实施清理

##### 5.5.3 终结条件

##### 5.5.4 垃圾回收器如何工作

JAVA从堆分配空间的速度，可以和其他语言从堆栈上分配空洞速度相媲美

java的堆指针只是简单的移动到尚未分配的区域，其效率比得上C++在堆栈上分配空间的效率

垃圾回收器的介入，使java内存工作时一面回收空间，一面使堆中的对象紧凑排列。通过垃圾回收器对对象的重排列实现了一种高速的，有无限空间可供分配的堆模型

其他系统的垃圾回收机制：  
1.引用计数，是一种简单但速度很慢的垃圾回收技术  
每个对象都含有一个引用计数器，当有引用连接对象时，计数加一；当引用离开作用域或被置为null时，计数减一。当发现某个对象的引用为0时，将其释放空间。  
存在缺陷，如果对象间存在循环引用，可能会出现“对象应该被回收，但引用计数不为0”的情况
2.停止-复制（不属于后台回收模式）  
先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有没复制的全部都是垃圾。  
对任何活的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。因此，如果从堆栈和静态存储区开始遍历所有引用，就能发现所有活的对象  
对于这种复制式回收器而言，效率会降低  
a.必须有两个堆，然后得在这两个分离的堆间来回倒腾，从而维护比实际需要多一倍的空间。JAVA的某些虚拟机对此的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大内存间  
b.复制的问题，程序进入稳定后，产生的垃圾可能极少，此回收器将所有内存自一处复制到另一处，这很浪费。为避免此情况，一些Java虚拟机会进行检查，要是没有新垃圾产生，会转换到另一种工作模式（标记-清扫）  
3.标记-清扫  
依据的思路同样是从堆栈和静态存储区开始遍历所有引用，发现所有活的对象，发现活的对象时会给对象设一个标记，这个过程不会进行垃圾回收。只有全部标记完成后，清理动作才开始，没有标记的被释放，不会发生任何复制动作，所以剩下的堆空间不是连续的  

垃圾回收器会定时进行完整的清理动作，大型对象不会被复制，但其代数会增加，小型对象的那些块则被复制并整理。JAVA虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”方式；要是堆空间出现很多碎片，就会切换会“停止-复制”方式

#### 5.6 成员初始化

类的每个基本类型数据成员保证都会有一个初始值  
在类中定义一个对象引用时，如果不进行初始化，此引用就会获得一个特殊的值null

##### 5.6.1 指定初始化

#### 5.7 构造器初始化

无法阻止自动初始化的进行，它将在构造器被调用之前发生

```
public class Counter{
	int i;
	Counter() {i=7;}
}
```

上面代码，i首先被置为0，然后变成7

##### 5.7.1 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用前得到初始化

##### 5.7.2 静态数据的初始化

无论创建多少个对象，静态数据都只占一份存储空间  
初始化的顺序是先静态对象（如果它们尚未因前面的对象创建过程而被初始化），而后非静态对象

对象的创建过程：
a.即使没有显示的使用static关键字，构造器实际上也是静态方法。因此当首次创建对象时，或对象的静态发方法/域首次被访问时，java解析器查找到类路径，定位class文件  
b.然后载入class，有关静态初始化的所有动作执行  
c.当new对象创建时，首先将堆上的对象分配足够的存储空间  
d.这块空间会被清0，对象中的基本类型设置默认值，引用类型设为null  
e.执行所有出现于字段定义处的初始化动作  
f.执行构造器

##### 5.7.3 显示的静态初始化

##### 5.7.4 非静态实例初始化

实例初始化子句是在构造器之前执行的

#### 5.8 数组初始化

int []a; int a[];

##### 5.8.1 可变参数列表

应用于参数个数或类型未知的场合

#### 5.9 枚举类型

在创建enum类型时，编译器会自动添加些有用的特性，toString(),ordinal(),values()
enum可以在switch中使用