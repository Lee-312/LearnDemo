#### 17.1 完整的容器分类法

图片搜索full container taxonomy

#### 17.2 填充容器

##### 17.2.1 一种Generator解决方案

CollectionDataTest,java

##### 17.2.2 Map生成器

MapDataTest.java

##### 17.2.3 使用Abstract类

享元设计模式

Countries.java

#### 17.3 Collection的功能方法

CollectionMethods.java

#### 17.4 可选操作

##### 17.4.1 未获支持的操作

Unsuported.java

#### 17.5 List的功能方法

#### 17.6 Set和存储顺序

#### 17.7 队列

##### 17.7.1 优先级队列

##### 17.7.2 双向队列

#### 17.8 理解Map

##### 17.8.1 性能

性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当的慢，而这正是HashMap提高速度的地方，HashMap使用了特殊的值，称为散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的，用以代表对象的int值，它通过将该对象的某些信息进行转换生成的。hashCode()是根类Object中的方法，因此所有Java对象都能产生散列码。HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。

##### 17.8.2 SortedMap

##### 17.8.3 LinkedHashMap

LRU的使用

#### 17.9 散列与散列码

使用Object的hashCode()方法生成的散列码，默认使用对象的地址来计算，要使对象存储在HashMap中正常运用，需要覆盖hashCode和equals方法

正确的equals方法必须满足：  
1.自反性x.equals(x)一定是ture  
2.对称性 如x.equals(y)，那么y.equals(x)也是true  
3.传递性 x.equals(y),y.equals(z)，则x.equals(z)  
4.一致性 x.equals(y)，如果对象用于等价比较的信息没有改变，那么调用多少次结果都一致  
5.对任何不是null的x，x.equlas(null)一定返回false

##### 17.9.1 理解hashCode()

使用散列的目的在于：想要使用一个对象来查找另一个对象

##### 17.9.2 为速度而散列

散列的价值在于速度：散列使得查询得以快速进行。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collections.binarySearch()进行查询。散列则更进一步，它将键保存在某处，以便能够快速找到。存储一组元素最快的数据结构是数组，所以使用它来表示键的信息，但是数组不是可变长度的，因此在希望保存数量不定的值的情况下数组就被限制住了，该怎么办？答案是，数组不保存键本身，而是通过对键对象生成一个数字，将其作为数组的下标，这个数字就是散列码。为解决数组容量被固定的问题，不同的键可以产生相同的下标，就是说会有冲突，因此数组多大就不重要了，任何键总能在数组中找到它的位置。  
于是查询一个值的过程首先就是计算散列码，然后使用散列码查询数组，如果能够保证没有冲突那么就有了一个完美的散列数组，但这种情况只是特例。通常冲突由外部链接处理：数组并不保存值，而是保存值的list。然后对list的值使用equals方法进行线性查询

SimpleHashMap.java

散列表中槽位通常被称为桶位，桶的数量通常使用质数

##### 17.9.3 覆盖hashCode()

CountedString.java

#### 17.10 选择接口的不同实现

##### 17.10.1 性能测试框架

##### 17.10.3 微基准测试的危险

##### 17.10.4 对Set的选择

##### 17.10.5 对Map的选择

#### 17.11 实用方法

##### 17.11.1 List的排序和查询

##### 17.11.2 设定Collection或Map为不可修改

##### 17.11.3 Collection或Map的同步控制

#### 17.12 持有引用

##### 17.12.1 WeakHashMap

#### 17.13 Java 1.0/1.1 容器

##### 17.13.1 Vector和Enumeration

##### 17.13.2 Hashtable

##### 17.13.3 Stack

##### 17.13.4 BitSet

#### 17.14 总结