运行时类型信息使得可以在程序运行时发现和使用类型信息  
Java是如何在运行时识别对象和类的信息的，主要由两种方式1.传统的RTTI，它假定在编译时就已经知道了所有的类型 2.反射机制，允许在运行时发现和使用类的信息

#### 14.1 为什么需要RTTI

在Java中，所有的类型转换都是在运行时进行正确性检查的，这也是RTTI的含义：在运行时，识别一个对象的类型

#### 14.2 Class对象

类型信息在运行时是通过Class对象的来表示的，事实上，Class对象就是用来创建类的所有的常规对象的  
类是程序的一部分，每个类都有一个Class对象，为了生成这个对象，运行这个程序的Java虚拟机将使用被称为“类加载器”的子系统  
类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分，原生加载器加载的所谓可信类，包括Java API类，它们通常从本地盘加载的  
所有类都是对其第一次使用时，动态加载到JVM中的，因此Java程序在开始运行时并非被完全加载，其各个部分是在必需时才加载的

使用newInstance()来创建的类，必须带有默认的构造器

##### 14.2.1 类字面常量

Java还提供了另一种方法来生成对Class对象的引用，即类字面常量  
如xxx.class 这样做不仅简单而且更安全，因为它在编译时就会受到检查，并且它根除了对forName()方法的调用，所以也更高效  
当使用.class来创建对Class对象的引用时，不会自动地初始化该Class对象，为了使用类而做的准备工作有三步  
1.加载，由类加载器执行，该步骤将查找字节码并从中创建一个Class对象  
2.链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用  
3.初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块  
初始化被延迟到了对静态方法或非常数静态域进行首次引用时才执行

初始化实现了尽可能的惰性，仅使用.class语法来获得对类的引用不会引发初始化，而使用Class.forName()则立即进行了初始化

如果一个static final值时“编译期常量”，那么这个值不需要对类进行初始化就能读取，但将一个域设置static final的还不足以确保这种行为。如果一个static域不是final的，那么在对它访问时总要求在它被读取前，先进行链接和初始化

##### 14.2.2 泛化的Class引用

普通的类引用可以重新被赋值为指向任何其他的Class对象，通过泛型语法，可以让编译器强制执行额外的类型检查，通配符“？”表示任何事物

##### 14.2.3 新的转型语法

cast()

#### 14.3 类型转换前先做检查

instanceof关键字

##### 14.3.1 使用类字面常量

##### 14.3.2 动态的instanceof

##### 14.3.3 递归计数