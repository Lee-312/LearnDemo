运行时类型信息使得可以在程序运行时发现和使用类型信息  
Java是如何在运行时识别对象和类的信息的，主要由两种方式1.传统的RTTI，它假定在编译时就已经知道了所有的类型 2.反射机制，允许在运行时发现和使用类的信息

#### 14.1 为什么需要RTTI

在Java中，所有的类型转换都是在运行时进行正确性检查的，这也是RTTI的含义：在运行时，识别一个对象的类型

#### 14.2 Class对象

类型信息在运行时是通过Class对象的来表示的，事实上，Class对象就是用来创建类的所有的常规对象的  
类是程序的一部分，每个类都有一个Class对象，为了生成这个对象，运行这个程序的Java虚拟机将使用被称为“类加载器”的子系统  
类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分，原生加载器加载的所谓可信类，包括Java API类，它们通常从本地盘加载的  
所有类都是对其第一次使用时，动态加载到JVM中的，因此Java程序在开始运行时并非被完全加载，其各个部分是在必需时才加载的

使用newInstance()来创建的类，必须带有默认的构造器

##### 14.2.1 类字面常量

Java还提供了另一种方法来生成对Class对象的引用，即类字面常量  
如xxx.class 这样做不仅简单而且更安全，因为它在编译时就会受到检查，并且它根除了对forName()方法的调用，所以也更高效  
当使用.class来创建对Class对象的引用时，不会自动地初始化该Class对象，为了使用类而做的准备工作有三步  
1.加载，由类加载器执行，该步骤将查找字节码并从中创建一个Class对象  
2.链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用  
3.初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块  
初始化被延迟到了对静态方法或非常数静态域进行首次引用时才执行

初始化实现了尽可能的惰性，仅使用.class语法来获得对类的引用不会引发初始化，而使用Class.forName()则立即进行了初始化

如果一个static final值时“编译期常量”，那么这个值不需要对类进行初始化就能读取，但将一个域设置static final的还不足以确保这种行为。如果一个static域不是final的，那么在对它访问时总要求在它被读取前，先进行链接和初始化

##### 14.2.2 泛化的Class引用

普通的类引用可以重新被赋值为指向任何其他的Class对象，通过泛型语法，可以让编译器强制执行额外的类型检查，通配符“？”表示任何事物

##### 14.2.3 新的转型语法

cast()

#### 14.3 类型转换前先做检查

instanceof关键字

##### 14.3.1 使用类字面常量

##### 14.3.2 动态的instanceof

##### 14.3.3 递归计数

#### 14.4 注册工厂

RegisteredFactories.java

#### 14.5 instanceof与Class的等价性

#### 14.6 反射：运行时的类信息

如果不知道某个对象的确切类型，RTTI可以告诉你，但有一个前提：这个类型在编译时必须已知，这样才能使用RTTI识别它，但是如果是在编译时程序无法获知对象的所属类（如磁盘文件，网络链接等），这时RTTI就无法使用。  
Class类和java.lang.reflect类库一起对反射进行了支持，使得对象的类信息能够在运行时被确认，而在编译时不需知道如何信息  
所以RTTI和反射间的区别在于，RTTI来说，编译器在编译时打开和检查.class文件；而反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件

##### 14.6.1 类方法提取器

#### 14.7 动态代理

代理说基本的设计模式之一，它提供了额外的或不同的操作，而插入的用来代替“实际”对象的对象  
动态代理，动态的创建代理并动态的处理所代理方法的调用，在动态代理上所作的所有调用都会被重定向到单一的调用处理器上，它的工作时揭示调用的类型并确定相应的对策

#### 14.8 空对象

当使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null，这显得枯燥，而且势必产生相当乏味的代码。问题在于null除了在试图使用它执行任何操作来产生NullPointerException之外，子句没有其他任何行为。有时引入空对象的思想会很有用，它接受传递给它的所代表的对象的消息，但是返回表示为实际上并不存在任何“真实”对象的值。通过这种方式，你可以假设所有对象都是有效的，而不必浪费编程精力去检查null

##### 14.8.1 模拟对象与桩

#### 14.9 接口与类型信息

interface关键字的一种重要目标就是允许程序员隔离构建，进而降低耦合性，但是通过类型信息，这种耦合性还是会传播出去--接口并非是对解耦的一种无懈可击的保障  
使用反射，仍旧可以调用所有方法，甚至是private的

#### 14.10 总结

