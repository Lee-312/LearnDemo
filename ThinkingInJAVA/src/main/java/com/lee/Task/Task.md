JVM运行时数据区  
1.线程共享部分  
    方法区，堆内存  
2.线程独占部分  
    虚拟机栈，本地方法区，程序计数器


线程状态6中
New,Runable,Blocked,Waiting,TimeWaiting,Terminated

不正确的线程终止 -- stop， 未保证同步代码块中数据等待一致性，破环了线程安全  
正确的线程终止 -- interrupt ,如目标线程在调用wait,join,sleep方法时被阻塞，那么interrupt会生效，该线程中断状态将被清除，抛出InterruptedException异常  
    如果，目标线程被IO或NIO中的Channel所阻塞，同样，IO操作会被中断或者返回特殊异常值，达到终止线程的目的  
    如不是以上条件，则会设置此线程的中断状态  
正确的线程终止 -- 标志位

CPU性能优化手段 - 缓存  
多级缓存  
L1 一层高速缓存，分为数据缓存和指令缓存，一般容量在32-4096KB  
L2 由于L1容量限制，为了再次提高CPU运算速度，在CPU外放置一高速存储器  
L3 现在都是内置的，实际作用是可以进一步降低内存延迟，同时提升大数据量计算处理器的性能。一般是多核共享L3  
CPU读取数据时，先找L1，再L2，然后L3，然后内存，最后外存储器  

缓存同步协议  
多CPU读取同样的数据进行缓存，进行不同运算后，最终写入主内存以哪个CPU为准？  
MESI协议，规定每条缓存有一个状态位，并定义了四个状态  
修改态(Modified)  此cache行已被修改过(脏读),内容已不同于主存，为此cache专有  
专有态(Exclusive) 此cache行内容同于主存，但不出现于其它cache中  
共享态(Shared) 此cache行内容同于主存，但也出现于其它cache中  
无效态(Invalid) 此cache行内容无效
多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其它CPU,CPU处理器要控制自己的读写操作，还要监听其它CPU发出的通知，从而保证最终一致  

CPU性能优化手段 - 运行时指令重排  
指令重排场景：当CPU写缓存时发现缓存区块正被其它CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行  
遵循as-if-serial语义：不管怎么重排，程序等待执行结果不能被改变。编译器，runtime和处理器都必须遵守该语义  
编译器和处理器不会对存在数据依赖关系的操作做重排序  

CPU性能优化产生两个问题  
1.高速缓存下，缓存中数据与主存并不实时同步，各CPU间缓存数据也不实时同步，在同一时间各CPU所看到的同一内存地址的数据可能不一致  
2.指令重排序虽遵守as-if-serial语义，但仅在单CPU执行下能保证结果，多核多线程中指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误  
处理器提供两个内存屏障(Memory Barrier)指令来解决这两个问题
1.写内存屏障(Store Memory Barrier):在指令后插入Store Barrier，让写入缓存中的最新数据更新写入主内存，让其它线程可见；强制写如主存，这种显示调用，CPU就不会因为性能考虑而去对指令重排
2.读内存屏障(Load Memory Barrier):在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主存加载数据；强制读取主内存内容，让CPU缓存与主存保证一致，避免了缓存导致的一致性问题



      		 